# -*- coding: utf-8 -*-
"""Solar Anomaly Analysis.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-B1WkmBBeMzQHtgcoCk6Nl5badM9mYA6
"""

import pandas as pd
import matplotlib.pyplot as plt
from sklearn.ensemble import IsolationForest
import numpy as np
from sklearn.preprocessing import StandardScaler
from scipy.stats import kurtosis, skew
import seaborn as sns
from sklearn.svm import OneClassSVM
from sklearn.neighbors import LocalOutlierFactor
from sklearn.metrics import precision_score, recall_score, f1_score, confusion_matrix, accuracy_score

inverter1 = pd.read_excel(r'C:/Users/Lenovo/Downloads/Anomaly detection in solar power generation/Data Set/Project-DataSet-15-10-2024.xlsx', sheet_name=1, skiprows=lambda x: x == 1)
inverter2 = pd.read_excel(r'C:/Users/Lenovo/Downloads/Anomaly detection in solar power generation/Data Set/Project-DataSet-15-10-2024.xlsx', sheet_name=2, skiprows=lambda x: x == 1)
inverter3 = pd.read_excel(r'C:/Users/Lenovo/Downloads/Anomaly detection in solar power generation/Data Set/Project-DataSet-15-10-2024.xlsx', sheet_name=3, skiprows=lambda x: x == 1, parse_dates=['DATE & TIME'])
weather = pd.read_excel(r'C:/Users/Lenovo/Downloads/Anomaly detection in solar power generation/Data Set/Project-DataSet-15-10-2024.xlsx', sheet_name=5, parse_dates=['DATE & TIME'])

# Add inverter identifier
inverter1['Inverter'] = 'INVERTER1'
inverter2['Inverter'] = 'INVERTER2'
inverter3['Inverter'] = 'INVERTER3'

# Combine inverter data
inverters = pd.concat([inverter1, inverter2, inverter3], ignore_index=True)

inverters['DATE & TIME'] = pd.to_datetime(inverters['DATE & TIME'], format='mixed').dt.floor('s')

# inverters['DATE & TIME'] = pd.to_datetime(inverters['DATE & TIME']).dt.strftime('%Y-%m-%d %H:%M')

weather['DATE & TIME'] = pd.to_datetime(weather['DATE & TIME'], format='mixed').dt.floor('s')

# weather['DATE & TIME'] = pd.to_datetime(weather['DATE & TIME']).dt.strftime('%Y-%m-%d %H:%M')

print(inverters.dtypes)

# Merge with weather data
data = pd.merge(inverters, weather, on='DATE & TIME', how='outer')

data.describe()

# Drop Near-Zero Variance and Zero-Variance Columns
data = data.drop(columns= [ "RAIN", "WIND DIRECTION", "WIND SPEED"])

# Set datetime as index
data.set_index('DATE & TIME', inplace=True)

# Fill NaN values with 0 for all columns except 'Inverter'
numerical_columns = data.columns.difference(['Inverter'])  # Exclude 'Inverter'
data[numerical_columns] = data[numerical_columns].fillna(0)

# data.info()

#Using the category data type for categorical variable like Inverter (if treated categorically) can save memory.
data['Inverter'] = data['Inverter'].astype('category')

# data.info()

# Optimizing the datatypes
data['DC CURRENT'] = data['DC CURRENT'].astype('float32')
data['DC VOLTAGE'] = data['DC VOLTAGE'].astype('float32')
data['DC POWER'] = data['DC POWER'].astype('float32')
data['TEMPERATURE'] = data['TEMPERATURE'].astype('float32')
data['MODULE TEMP.1'] = data['MODULE TEMP.1'].astype('float32')
data['MODULE TEMP.2'] = data['MODULE TEMP.2'].astype('float32')
data['HUMIDITY'] = data['HUMIDITY'].astype('float32')
data['AMBIENT TEMPERATURE'] = data['AMBIENT TEMPERATURE'].astype('float32')

# Converting 'Inverter' to category
data['Inverter'] = data['Inverter'].astype('category')

# Converting GHI and GII to integers, using int8 or int16 based on the range
data['GHI'] = data['GHI'].astype('int32')
data['GII '] = data['GII '].astype('int32')

# Verify the memory usage after optimization
# print(data.info())

# Remove extra spaces from all column names
data.columns = data.columns.str.strip()

# Extract temporal features
data['Hour'] = data.index.hour.astype('int8')
data['Day'] = data.index.day.astype('int8')
data['Month'] = data.index.month.astype('int8')

# Calculate Power_per_GHI, handling division by zero
data['Power_per_GHI'] = (data['DC POWER'] / data['GHI'].replace(0, np.nan)).astype('float32')
data['Power_per_GHI'].fillna(0, inplace=True)

data

# Calculate DC POWER from DC CURRENT and DC VOLTAGE
data['Calculated_DC_POWER'] = (data['DC CURRENT'] * data['DC VOLTAGE'])/1000

# Analyze the differences
data['Power_Match'] = np.isclose(data['Calculated_DC_POWER'], data['DC POWER'], rtol=1e-1)

# Count how many match and how many don't
power_matches = data['Power_Match'].value_counts()

# Print the counts of matches and mismatches
print("Power Matches:\n", power_matches)

# Optionally, if you want to see the mismatches:
mismatched_data = data[~data['Power_Match']]
print("\nMismatched Data:\n", mismatched_data[['DC CURRENT', 'DC VOLTAGE', 'DC POWER', 'Calculated_DC_POWER']])

data

# Calculate the correlation matrix
correlation_matrix = data[numerical_columns].corr()

# Set up the matplotlib figure
plt.figure(figsize=(12, 8))

# Draw the heatmap
sns.heatmap(correlation_matrix, annot=True, fmt='.2f', cmap='coolwarm', square=True, cbar_kws={"shrink": .8})

# Set the title
plt.title('Correlation Heatmap', fontsize=16)

# Show the plot
plt.show()

# Remove columns with high correlation
columns_to_remove = ['GHI', 'GII', 'Calculated_DC_POWER', 'DC CURRENT', 'MODULE TEMP.1', 'MODULE TEMP.2', 'Power_per_GHI']
data = data.drop(columns=columns_to_remove)

# Verify the removal
print(data.columns)

data

# Group by 'Hour' and 'Inverter', then calculate the mean of 'DC POWER' for each group
hourly_avg_power = data.groupby(['Hour', 'Inverter'])['DC POWER'].mean().reset_index()

# Plot the hourly average power for each inverter
plt.figure(figsize=(12, 6))
sns.lineplot(x='Hour', y='DC POWER', hue='Inverter', data=hourly_avg_power, marker='o')

# Adding labels and title
plt.title('Hourly Average Power Generation by Inverter', fontsize=14)
plt.xlabel('Hour of the Day', fontsize=12)
plt.ylabel('Average DC Power (W)', fontsize=12)
plt.xticks(ticks=range(0, 24), labels=range(0, 24))  # Ensure the x-axis has 24 hours
plt.grid(True)
plt.legend(title='Inverter', fontsize=10)

# Display the plot
plt.tight_layout()
plt.show()

# Group by 'Day' and 'Inverter', then calculate the mean of 'DC POWER' for each group
Day_avg_power = data.groupby(['Day', 'Inverter'])['DC POWER'].mean().reset_index()

# Plot the Days average power for each inverter
plt.figure(figsize=(12, 6))
sns.lineplot(x='Day', y='DC POWER', hue='Inverter', data=Day_avg_power, marker='o')

# Adding labels and title
plt.title('Days Average Power Generation by Inverter', fontsize=14)
plt.xlabel('Day', fontsize=12)
plt.ylabel('Average DC Power (W)', fontsize=12)
plt.xticks(ticks=range(1, 32), labels=range(1, 32))  # Ensure the x-axis has 31 days
plt.grid(True)
plt.legend(title='Inverter', fontsize=10)

# Display the plot
plt.tight_layout()
plt.show()

# Group by 'Month' and 'Inverter', then calculate the mean of 'DC POWER' for each group
Month_avg_power = data.groupby(['Month', 'Inverter'])['DC POWER'].mean().reset_index()

# Plot the months average power for each inverter
plt.figure(figsize=(12, 6))
sns.lineplot(x='Month', y='DC POWER', hue='Inverter', data=Month_avg_power, marker='o')

# Adding labels and title
plt.title('Monthly Average Power Generation by Inverter', fontsize=14)
plt.xlabel('Month', fontsize=12)
plt.ylabel('Average DC Power (W)', fontsize=12)
plt.xticks(ticks=range(1, 13), labels=range(1, 13))  # Ensure the x-axis has 12 months
plt.grid(True)
plt.legend(title='Inverter', fontsize=10)

# Display the plot
plt.tight_layout()
plt.show()

import pandas as pd

# Define custom bins for the 'Hour' column
bins = [-1, 4, 9, 14, 18]  # Adjust the last bin edge to 24
labels = ['Night', 'Morning', 'Afternoon', 'Evening']  # Remove duplicate 'Night'

# Create a new column 'TimeOfDay' based on the bins
data['TimeOfDay'] = pd.cut(data['Hour'], bins=bins, labels=labels, right=True, include_lowest=True)

# For the hours 19 to 23, set them to 'Night' after binning
data.loc[data['Hour'].between(19, 23), 'TimeOfDay'] = 'Night'

# Display the first few rows of the dataframe to check the new column
print(data[['Hour', 'TimeOfDay']].head(10))

data.drop(columns=["Power_Match"], inplace=True)

data['TimeOfDay'].unique()

data

filtered_data = data[data['TimeOfDay'].isin(['Night'])]

# Create a line plot with ambient temperature on the x-axis and DC power on the y-axis
plt.figure(figsize=(14, 7))
sns.lineplot(data=filtered_data, x='AMBIENT TEMPERATURE', y='DC POWER', hue='Inverter',
             estimator='sum', palette='Set1')

# Set titles and labels
plt.title('Power Generation vs Ambient Temperature')
plt.xlabel('Ambient Temperature (Â°C)')
plt.ylabel('Average DC Power Generation (W)')
plt.legend(title='Inverter')
plt.grid()
plt.tight_layout()

# Show plot
plt.show()

data = data[data['TimeOfDay'] != 'Night']

data

# Initialize scaler
scaler = StandardScaler()

data_scaled = data[["DC VOLTAGE", "DC POWER", "TEMPERATURE", "HUMIDITY", "AMBIENT TEMPERATURE"]].copy()

# Fit and transform in place
data_scaled = scaler.fit_transform(data_scaled.astype('float32'))

data_scaled

# Initialize Isolation Forest
iso_forest = IsolationForest(
    n_estimators=100,
    contamination=0.01,  # Adjust based on expected anomaly rate
    random_state=42,
    n_jobs=-1  # Utilize all available CPU cores
)

# Fit the model
iso_forest.fit(data_scaled)

# Predict anomalies (-1 for anomaly, 1 for normal)
data.loc[:, 'Anomaly_IF'] = iso_forest.fit_predict(data_scaled)

data

# Filter anomalies
anomalies = data[data['Anomaly_IF'] == -1]
print(f"Number of anomalies detected: {len(anomalies)}")

anomalies.describe()

anomalies.to_excel('anomalies.xlsx', index=True)

# Create a scatter plot for anomalies, color-coded by inverter type
plt.figure(figsize=(14, 7))

# Using seaborn to create a palette for the inverter types
palette = sns.color_palette("husl", len(anomalies['Inverter'].unique()))

# Create a scatter plot for each inverter
for i, inverter in enumerate(anomalies['Inverter'].unique()):
    inverter_data = anomalies[anomalies['Inverter'] == inverter]
    plt.scatter(inverter_data['AMBIENT TEMPERATURE'], inverter_data['DC POWER'],
                color=palette[i], label=f'{inverter} (Count: {len(inverter_data)})', s=10)

plt.legend(title='Inverter')
plt.title('DC POWER with Anomalies Highlighted')
plt.xlabel('AMBIENT TEMPERATURE')
plt.ylabel('DC POWER')
plt.show()

# Create a scatter plot for anomalies, color-coded by inverter type
plt.figure(figsize=(14, 7))

# Using seaborn to create a palette for the inverter types
palette = sns.color_palette("husl", len(anomalies['Inverter'].unique()))

# Create a scatter plot for each inverter
for i, inverter in enumerate(anomalies['Inverter'].unique()):
    inverter_data = anomalies[anomalies['Inverter'] == inverter]
    plt.scatter(inverter_data['HUMIDITY'], inverter_data['DC POWER'],
                color=palette[i], label=f'{inverter} (Count: {len(inverter_data)})', s=10)

plt.legend(title='Inverter')
plt.title('DC POWER with Anomalies Highlighted')
plt.xlabel('HUMIDITY')
plt.ylabel('DC POWER')
plt.show()

# Initialize One-Class SVM
oc_svm = OneClassSVM(kernel='rbf', gamma='scale', nu=0.01)  # Adjust 'nu' for anomaly rate

# Initialize Local Outlier Factor
lof = LocalOutlierFactor(n_neighbors=20, contamination=0.01, novelty=True)

data.loc[:, 'Anomaly_SVM'] = oc_svm.fit_predict(data_scaled)

data

# Filter anomalies for each model
anomalies_iso = data[data['Anomaly_IF'] == -1]
anomalies_svm = data[data['Anomaly_SVM'] == -1]

anomalies_svm

anomalies['Inverter'].unique()

# Create a scatter plot for anomalies, color-coded by inverter type
plt.figure(figsize=(14, 7))

# Using seaborn to create a color palette for the inverter types
palette = sns.color_palette("husl", len(anomalies_svm['Inverter'].unique()))

# Create a scatter plot for each inverter
for i, inverter in enumerate(anomalies['Inverter'].unique()):
    inverter_data = anomalies_svm[anomalies_svm['Inverter'] == inverter]
    plt.scatter(inverter_data['AMBIENT TEMPERATURE'], inverter_data['DC POWER'],
                color=palette[i], label=f'{inverter} (Count: {len(inverter_data)})', s=10)

plt.legend(title='Inverter')
plt.title('DC POWER with Anomalies Highlighted')
plt.xlabel('AMBIENT TEMPERATURE')
plt.ylabel('DC POWER (scaled)')
plt.show()

lof.fit(data_scaled)

data.loc[:, 'Anomaly_LOF'] = lof.predict(data_scaled)

anomalies_lof = data[data['Anomaly_LOF'] == -1]

# Create a scatter plot for anomalies, color-coded by inverter type
plt.figure(figsize=(14, 7))

# Using seaborn to create a palette for the inverter types
palette = sns.color_palette("husl", len(anomalies_lof['Inverter'].unique()))

# Create a scatter plot for each inverter
for i, inverter in enumerate(anomalies['Inverter'].unique()):
    inverter_data = anomalies_lof[anomalies_lof['Inverter'] == inverter]
    plt.scatter(inverter_data['AMBIENT TEMPERATURE'], inverter_data['DC POWER'],
                color=palette[i], label=f'{inverter} (Count: {len(inverter_data)})', s=10)

plt.legend(title='Inverter')
plt.title('DC POWER with Anomalies Highlighted')
plt.xlabel('AMBIENT TEMPERATURE')
plt.ylabel('DC POWER (scaled)')
plt.show()

# Define evaluation metric functions (since there's no ground truth, we will compare based on output similarity)
def evaluation_metrics(model_name, anomaly_labels):
    tn, fp, fn, tp = confusion_matrix(data['Anomaly_IF'], anomaly_labels, labels=[1, -1]).ravel()
    accuracy = accuracy_score(data['Anomaly_IF'], anomaly_labels)
    precision = precision_score(data['Anomaly_IF'], anomaly_labels, pos_label=-1)
    recall = recall_score(data['Anomaly_IF'], anomaly_labels, pos_label=-1)
    f1 = f1_score(data['Anomaly_IF'], anomaly_labels, pos_label=-1)

    print(f"{model_name} Metrics:")
    print(f"Accuracy: {accuracy:.4f}")
    print(f"Precision: {precision:.4f}")
    print(f"Recall: {recall:.4f}")
    print(f"F1-Score: {f1:.4f}")
    print(f"Confusion Matrix: \n{tn, fp, fn, tp}")
    print("="*50)

# Evaluate each model compared to Isolation Forest results
evaluation_metrics("One-Class SVM", data['Anomaly_SVM'])
evaluation_metrics("Local Outlier Factor (LOF)", data['Anomaly_LOF'])

# Visualization of Anomalies
plt.figure(figsize=(14,7))

# Plot for Isolation Forest
plt.scatter(anomalies.index, anomalies['DC POWER'], color='red', label='IF Anomalies', s=10)

# Plot for SVM
plt.scatter(anomalies_svm.index, anomalies_svm['DC POWER'], color='blue', label='SVM Anomalies', s=10)

# Plot for LOF
plt.scatter(anomalies_lof.index, anomalies_lof['DC POWER'], color='green', label='LOF Anomalies', s=10)

plt.legend()
plt.title('DC POWER with Anomalies Highlighted (IF, SVM, LOF)')
plt.xlabel('Time')
plt.ylabel('DC POWER (scaled)')
plt.show()

# Visualization of Anomalies
plt.figure(figsize=(14,7))

# Plot for Isolation Forest
plt.scatter(anomalies['AMBIENT TEMPERATURE'], anomalies['DC POWER'], color='red', label='IF Anomalies', s=10)

# Plot for SVM
plt.scatter(anomalies_svm['AMBIENT TEMPERATURE'], anomalies_svm['DC POWER'], color='blue', label='SVM Anomalies', s=10)

# Plot for LOF
plt.scatter(anomalies_lof['AMBIENT TEMPERATURE'], anomalies_lof['DC POWER'], color='green', label='LOF Anomalies', s=10)

plt.legend()
plt.title('DC POWER with Anomalies Highlighted (IF, SVM, LOF)')
plt.xlabel('AMBIENT TEMPERATURE')
plt.ylabel('DC POWER (scaled)')
plt.show()

# Visualization of Anomalies
plt.figure(figsize=(14,7))

# Plot for Isolation Forest
plt.scatter(anomalies.HUMIDITY, anomalies['DC POWER'], color='red', label='IF Anomalies', s=10)

# Plot for SVM
plt.scatter(anomalies_svm.HUMIDITY, anomalies_svm['DC POWER'], color='blue', label='SVM Anomalies', s=10)

# Plot for LOF
plt.scatter(anomalies_lof.HUMIDITY, anomalies_lof['DC POWER'], color='green', label='LOF Anomalies', s=10)

plt.legend()
plt.title('DC POWER with Anomalies Highlighted (IF, SVM, LOF)')
plt.xlabel('HUMIDITY')
plt.ylabel('DC POWER (scaled)')
plt.show()

#data.to_csv('data.csv', index=True)